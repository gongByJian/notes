
事务
	<bean id="hibernateTransactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager">
        <property name="sessionFactory">
            <ref local="sessionFactory"/>
        </property>
    </bean>      
    <!-- Transactional proxy for the services --> 
    <bean id="hibernateTxProxy" lazy-init="true" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"> 
        <property name="transactionManager"><ref bean="hibernateTransactionManager"/></property> 
        <property name="transactionAttributes"> 
            <props> 
            		<prop key="add*">PROPAGATION_REQUIRED</prop>
            		<prop key="save*">PROPAGATION_REQUIRED</prop>
            		<prop key="remove*">PROPAGATION_REQUIRED</prop>
            		<prop key="load*">PROPAGATION_REQUIRED,readOnly</prop> 
            		<prop key="get*">PROPAGATION_REQUIRED,readOnly</prop> 
            		<prop key="do*">PROPAGATION_REQUIRED</prop>
            		<prop key="import*">PROPAGATION_REQUIRED</prop>
            </props> 
        </property> 
    	<property name="target"><bean class="db.BaseBiz" autowire="byName"/></property>
    </bean>

Dao 继承基类
	org.springframework.orm.hibernate3.support.HibernateDaoSupport

JdbcTemplate插入mysql后返回id值

	//import org.springframework.jdbc.support.GeneratedKeyHolder;
	//import org.springframework.jdbc.support.KeyHolder;	
	//import org.springframework.jdbc.core.PreparedStatementCreator;
	//import java.sql.Statement;
	public int insert(final String sql) throws Exception {
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(new PreparedStatementCreator() {   
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {   
                PreparedStatement ps = con.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);   
                return ps;   
            }   
        }, keyHolder);   

		
		Map map = (Map)keyHolder.getKeyList().get(0);
		return Integer.valueOf(map.get("GENERATED_KEY").toString());
	}

struts Action代理
	org.springframework.web.struts.DelegatingActionProxy

web.xml
	<display-name>test11</display-name>
	<context-param>
		<param-name>webAppRootKey</param-name>
		<param-value>test11</param-value>
	</context-param>
	
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>				
			/WEB-INF/classes/applicationContext.xml			
		</param-value>
	</context-param>
	
	<listener>
		<listener-class>
			org.springframework.web.context.ContextLoaderListener
		</listener-class>
	</listener>
	<listener>
		<listener-class>
			<!--动态的改变记录级别和策略，不需要重启Web应用-->
			<!--把log文件定在 /WEB-INF/logs/ 而不需要写绝对路径。log4j.appender.logfile.File=${webapp.root}/WEB-INF/logs/myfuse.log-->
			<!--可以把log4j.properties和其他properties一起放在/WEB-INF/ ，而不是Class-Path。-->
			<!--.log4jRefreshInterval为60000表示 开一条watchdog线程每60秒扫描一下配置文件的变化-->
			org.springframework.web.util.Log4jConfigListener
		</listener-class>
	</listener>
	<listener>
		<listener-class><!--它主要负责处理由 JavaBeans Introspector的使用而引起的缓冲泄露-->
			org.springframework.web.util.IntrospectorCleanupListener
		</listener-class>
	</listener>

多个ssh项目无法启动
	在web.xml加入以下代码
	<display-name>test</display-name>
	<context-param>
		<param-name>webAppRootKey</param-name>
		<param-value>test</param-value>
	</context-param>

通过HibernateDaoSupport获取session不关闭问题解决
	
	通过匿名内部类获取session，session可以回收

	public PageEntity getList(final String hql, final int cp, final int pageItem)
	{
		HibernateCallback callback = new HibernateCallback() {
			public Object doInHibernate(Session session){
				
				String countPageHql = "select count(*) as countItem "+ hql.substring(hql.indexOf("from "),hql.length());
				List countList = Dao.this.getList(countPageHql);
				int countItem = ((Long)countList.get(0)).intValue();
				
				//共多少页
				int countPage = (int)(countItem-1)/pageItem+1;
				
				//开始条数
				int startItem = (cp-1)*pageItem;
				
				Query query = session.createQuery(hql);
				query.setFirstResult(startItem);
				query.setMaxResults(pageItem);
				List list = query.list();
				
				PageEntity pe = new PageEntity();
				pe.setCountItem(countItem);
				pe.setCountPage(countPage);
				pe.setCp(cp);
				pe.setList(list);
				pe.setPageItem(pageItem);
				
				return pe;
			}
		};
		return (PageEntity) getHibernateTemplate().execute(callback);
		
	}

把struts2交给spring来管理
	<constant name="struts.objectFactory" value="spring"></constant>

hibernate 显示sql
	<property name="hibernateProperties">
		<props>
			<prop key="hibernate.dialect">
				org.hibernate.dialect.MySQLDialect
			</prop>
			<prop key="hibernate.show_sql">true</prop>
		</props>
	</property>

错误处理
	java.lang.NoClassDefFoundError: org/hibernate/cfg/HbmBinder$SecondPass
		直接删除:hibernate-annotations.jar

	spring2加入事物IOC报类型转换错误
		错误： Cannot convert value of type [$Proxy0 implementing org.springframework.beans.factory.InitializingBean,org.springframework.aop.SpringProxy,org.springframework.aop.framework.Advised] to required type [com.baidu.Dao] for property 'dao': no matching editors or conversion strategy found

		解决办法：
		1. <aop:aspectj-autoproxy proxy-target-class="true"/>   启动自动转换cglib注入方式
		2. 把cglib-2.2.jar版本换成 cglib-2.1.3.jar
		3. 把asm-2.2.3.jar换成asm.jar

	java.lang.ClassNotFoundException: org.apache.commons.collections.map.LRUMap
		把commons-collections-3.1.jar放入tomcat

	
    java.lang.NoSuchMethodError: org.objectweb.asm.ClassWriter.<init>(I)V
		asm.jar和cglib-2.2.jar有冲突，把cglib-2.2.jar改成cglib-2.1.jar